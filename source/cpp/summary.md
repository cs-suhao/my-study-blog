# C++面经

## 概览
1. C++代码执行的过程。
2. 面向对象的三个基本特征是什么？各有什么作用和区别？
3. C++和C最大的区别是什么？
4. 面向过程和面向对象各自的优缺点？
5. C++是类型安全的语言吗？
6. C++的多态是如何实现的？
7. 动态链接相对静态链接解决的问题是什么？
8. 动态链接是什么？
9. 静态链接是什么？
10. C++的四种强制转换类型
    > 1. static_cast：用来进行比较“自然”和低风险的转换，比如整形和实数型、字符型之间互相转换。比C语言的类型转换：更加安全；更直接明显，能够一眼看出是什么类型转换为什么类型，容易找出程序中的错误；可清楚地辨别代码中每个显式的强制转；可读性更好，能体现程序员的意图
    > 2. reinterpret_cast：用来进行各种不同类型的指针之间的转换、不同类型的引用之间转换、以及指针和能容纳得下指针的整数类型之间的转换。转换的时候，执行的是逐个比特拷贝的操作。

11. C++模板是什么？
12. 模板类的实现可以放到C++的.cpp文件中吗？


## 内存
1. C++种虚拟地址空间有哪些组成部分？其中每个部分存放什么？
    > - 栈：由编译器管理分配和回收，存放局部变量和参数。
    > - 堆：由程序员管理，用new/malloc分配。
    > - 全局/静态存储区：分为初始化和未初始化两个相邻区域，存放全局变量和静态变量。
    > - 常量存储区：存储常量，不允许修改。
    > - 代码区：存放程序的二进制代码。

2. C++中内存分配和内存管理的函数有哪些？
3. C++/C中内存拷贝通常使用什么函数？
4. new和malloc有什么区别？对应的析构操作是什么？
5. malloc申请的空间没有及时释放会导致哪些问题？
6. 如果发生内存泄漏，该如何定位错误并解决？
7. 堆栈溢出会导致什么问题？
8. C++的浅拷贝和深拷贝有什么区别？
9.  struct中内存是如何对齐的，以32/64位系统为例。

## 虚函数
1. C++中虚函数是什么概念？
2. C++虚指针是什么，对应的虚表是如何运作的？
    > 运行时多态是由虚函数实现的，而虚函数是由虚表实现的。如果一个类中还有虚函数，那么这个类就会包含虚表，虚表中的每一项都是虚函数的入口地址。
    > 类的每一个对象都会包含一个虚指针，在对象实例地址的最前面，虚指针指向虚函数表。如果类继承了多个基类，那么类的每一个对象都会包含多个虚指针，分别指向这几个虚表。其实现的方式是地址偏移。
    > [参考](https://www.cnblogs.com/xiaokang01/p/12394420.html)
3. 析构函数可以是虚函数吗？
4. 构造函数可以是虚函数吗？
5. 析构和构造函数中可以使用虚函数吗？
6. 什么是纯虚函数？

## 指针与引用
1. 指针和引用的区别？
    > 1. 类型：指针是一个变量，存储的是变量(对象)的地址，引用是变量的别名
    > 2. 初始化是否可以为空：指针可以为空，引用定义时必须初始化。
    > 3. 初始化后是否可以改变指向:指针在初始化之后可以改变指向同一个卡类型实体，引用在初始化之后不可在改变。
    > 4. 指向是否为空：不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。因此可以说引用比指针安全。
    > 5. 是否多级：指针可以有多级，引用只有一级。
    > 6. sizeof大小：sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小。
    > 7. 内存：引用本质是一个指针，同样会占4字节内存；指针是具体变量，需要占用存储空间。
    > 8. 传参：当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
    > 9. 自加1:引用自加即引用的实体增加1,指针自加即指针向后偏移一个类型的大小。
    > 10. 访问实体的方式不同：指针需要显式解引用,引用编译器自己处理。

2. C++中不同类型的指针能不能强制转换？
    > 可以，参见上面的四种强制类型转换方法。

3. C++中值传递和引用传递的区别？如果参数是指针，是哪一种传递？
   
4. 智能指针有哪些？它们的应用场景是什么？
    > - shared_ptr：参考下一个问题。
    > - unique_ptr：一个unique_ptr拥有它所指向的对象。某个时刻只能有一个unique_ptr指向一个给定对象。当unique_ptr被销毁时，它所指向的对象也被销毁。
    > - weak_ptr：弱指针用于专门解决shared_ptr循环引用的问题，weak_ptr不会修改引用计数，即其存在与否并不影响对象的引用计数器。

5. shared_ptr的底层实现是怎样的？为什么会出现循环引用的问题？
    > shared_ptr通过引用计数的方式实现多个shared_ptr对象之间共享资源。
    > 但是shared_ptr是存在线程安全问题的，因为每多一个对象引用，就会对计数值++或--，如果两个shared_ptr同时++，则会产生竞争，因此对于引用计数值的操作是需要加锁的。
    > 同时shared_ptr存在循环引用的问题，如结构体中有next和pre两个智能指针，当两个节点互为前后节点，那么在对应智能指针的计数引用中，两个数值都是2，而不是1，会产生死循环。
    > [参考](https://cloud.tencent.com/developer/article/1688444)
6. 函数的返回值可以是unique_ptr吗？为什么？
    > 可以，unique_ptr不能copy ，但是可以move。作为函数返回值，并不是生成了一个新的指针，只是生成了临时变量（右值）作为返回值。 以前没右值引用时只能拷贝, 现在可以move了。

7. C++的左值引用和右值引用有什么区别？
8. 智能指针可以能不能转成void类型？
9. 智能指针转成void类型如何析构？
10. 静态变量出现两个地址如何解决？

## 关键字static、const、explicit、volatile
1. static变量是什么时候初始化的？
2. C++中全局静态变量和局部静态变量有什么区别？
    > - 作用域不同，全局整个周期都可见，而局部只在自己的作用域可见。

3. 动态链接库中的全局变量同时被两个程序调用，会产生什么错误？
    > 不会产生错误。
    > 动态库中的全局变量，在被其他进程使用时，会拷贝一份，所以多个进程使用同一个动态库中的全局变量也不会相互影响。也不会改变动态库中该变量的值。
    > 而如果是同一个进程下的多线程，则就会产生覆盖的错误。
4. const修饰的变量的区别
5. const与宏的区别以及使用场景？
6. explicit是什么？
7. volatile是什么？
8. sizeof相关
   > 1. sizeof数组与指针：当sizeof(数组名)时，长度为*类型大小.长度*，而sizeof(指针)时，就是对应指针的大小，指针的大小和对应的编译器有关，可能是4/8。并且需要注意的是，当数组作为参数传递，实际上会退化为指针。
   > 2. sizeof和类进行结合。空类的大小为1，成员函数、虚函数等不占据类对象的空间，如果有继承抽象类，每继承一个就有一个vptr，对应的大小是8。

## 泛型编程
1. 什么是单例模式？
2. 什么是工厂模式？
3. 泛型编程如何实现？

## 多线程
1. 如何实现一个线程池？
2. 如何实现两个线程循环打印1-100？
```cpp
#include <thread>
#include <mutex>
#include <vector>
#include <iostream>
#include <condition_variable>

using namespace std;

mutex mut;
condition_variable cond1, cond2;
int num = 1;

void thread1(int limit){
    while(num<limit){
        unique_lock<mutex> locker(mut);
        cout<<"thread1: "<< num << endl;
        num++;
        cond2.notify_one();
        cond1.wait(locker);
        locker.unlock();
    }
}

void thread2(int limit){
    while(num<limit){
        unique_lock<mutex> locker(mut);
        cout<<"thread2: " << num << endl;
        num++;
        cond1.notify_one();
        cond2.wait(locker);
        locker.unlock();
    }
}


int main(){
    thread t1(thread1, 100);
    thread t2(thread2, 100);
    t1.join();
    t2.join();
    return 0;
}
```

3. 多线程join和detach的区别？